# Fluxmaster — Feature Inventory

## Current Features (Implemented)

### Backend — Server Package (`packages/server`)
- Fastify 5 REST API with route plugins
- WebSocket streaming with `requestId` correlation
- Auto-spawn agents from `fluxmaster.config.json` on startup
- REST endpoints: agents CRUD, tools, MCP servers, auth status, config, plugins, system health, usage, cost, conversations, requests, security audit, budgets, workflows
- CORS + static file serving for production SPA
- Error handler mapping `FluxmasterError` subclasses to HTTP status codes
- Zod request body validation middleware
- Connection manager with heartbeat for WebSocket
- Tool result forwarding via WebSocket (`tool_result` events with content and error status)

### Backend — Core Packages
- Multi-agent orchestrator with agentic loop (tool use → re-prompt)
- Copilot enterprise auth proxy + direct API key auth
- Claude CLI token detection
- MCP server manager (stdio/SSE transports, auto tool registration)
- Browser automation via Playwright (navigate, click, type, screenshot, evaluate)
- Plugin system with lifecycle hooks
- Streaming support with retry logic
- EventBus — typed pub/sub with 24 event types covering agent lifecycle, messages, tools, MCP, cost, security, budget, and workflow events

### Frontend — Web Package (`packages/web`)

#### Layout & Navigation
- Sidebar with nav links: Chat, Dashboard, Admin
- Connection status indicator (Connected/Disconnected)
- Header with page title
- React Router with 3 routes: `/` (Chat), `/dashboard`, `/admin`

#### Chat Page
- Real-time streaming chat via WebSocket
- Markdown rendering for assistant messages (react-markdown + remark-gfm)
- Syntax-highlighted code blocks with language labels (react-syntax-highlighter + oneDark theme)
- Inline code, bold, italic, lists, links, blockquotes, tables
- User messages rendered as plain text (no markdown)
- Agent selector dropdown (switch between agents)
- Auto-scrolling message list
- User/assistant message bubbles with timestamps
- Streaming text display with live updates
- Expandable tool call indicators — click to reveal tool result content
- Tool call status: pending spinner, done checkmark, error X
- Error styling for failed tool calls with result details
- Enter to send, Shift+Enter for newline
- Send button with disabled state during streaming
- Clear conversation button per agent
- Empty state when no messages
- Conversation title (auto-generated by AI from first messages)
- Suggested follow-up questions after assistant responses

#### Dashboard Page
- Agent status cards (id, model, status dot)
- Responsive agent grid
- System health display (status + uptime)
- Usage summary (total input/output tokens, request count)
- Per-agent usage bar chart
- Cost summary (total cost, per-agent cost breakdown)
- Cost-by-agent chart
- Budget progress bars with color coding (green/yellow/red)
- Budget alerts list (warning/exceeded)

#### Admin Page (6 tabs)
- **Config**: JSON config display, Edit/Cancel/Save toggle, textarea editor
- **Agents**: Live agent list with id, model, status dot, count badge, and kill button per agent; Spawn agent form (id + model inputs, spawn button with validation)
- **MCP**: Server list with start/stop buttons, or empty state
- **Plugins**: Plugin list or empty state
- **Auth**: Copilot configured/ready, Claude CLI, direct providers status
- **Security**: Tool audit log with filtering, tool permissions display

#### Debug Panel
- Request list with status indicators and timing
- Expandable request details (tokens, duration, tool calls)
- TTFT (time to first token) and total duration metrics

#### Infrastructure
- Vite 6 + React 19 + Tailwind CSS 4
- TanStack React Query 5 for data fetching
- Zustand 5 for chat state management (ephemeral — persistence is server-side SQLite)
- WebSocket client with auto-reconnect and exponential backoff
- API fetch wrapper with error handling
- Path alias (`@/` and `@fluxmaster/api-types`)
- Dev proxy: `/api` → API server, `/ws` → WebSocket
- Keyboard shortcuts: `Cmd/Ctrl+K` command palette, `Cmd+1/2/3` page nav, `Cmd+/` focus input, `Escape` cancel streaming
- Export conversations as JSON or Markdown; import from JSON
- Dev startup script (`scripts/dev.sh`) with port conflict handling

### Phase 1: Foundation (Complete)

**Event Bus**
- `FluxmasterEvent` discriminated union with 24 event types
- `EventBus` with typed `emit()`, `on()`, `once()`, `off()` in `packages/core`
- Runtime-agnostic (no Node.js EventEmitter dependency)
- `WsEventBridge` forwards curated events to WebSocket clients
- `EventPersister` saves events to SQLite for replay

**Cost Tracking**
- Model pricing table in config (input/output per 1M tokens)
- `CostCalculator` wraps UsageTracker + pricing config
- Dynamic agent model tracking via `agent:spawned` event listener
- Per-agent and total cost API endpoints
- Cost display in dashboard

**Keyboard Shortcuts & Command Palette**
- `useKeyboardShortcuts` hook with `ShortcutDef[]`, platform-aware (Cmd vs Ctrl)
- Command palette with fuzzy search
- Shortcut hints next to actions

**Export/Import**
- JSON export with versioned format (agent, model, date, token counts)
- Markdown export with YAML frontmatter
- JSON import with validation
- Export button in chat view

### Phase 2: Developer Experience (Complete)

**SQLite Storage**
- `DatabaseManager` with WAL mode in `packages/server/src/db/`
- Numbered migration system (001–005)
- Stores: `SqliteConversationStore`, `SqliteEventStore`, `SqliteUsageStore`, `SqliteRequestStore`, `SqliteAiFeatureStore`
- Server-side persistence replaces localStorage as primary store

**Replay/Debug Panel**
- `RequestTracker` captures request lifecycle events
- Debug sidebar with request list, timing, token breakdown
- TTFT and total duration metrics per request
- Tool call details with input/output/duration

**AI-Assisted Features**
- `AiFeatureService` subscribes to `message:completed` events
- Auto-title conversations from first messages (fire-and-forget via `_ai-features` agent)
- Suggested follow-up questions after assistant responses
- `SqliteAiFeatureStore` persists generated titles and suggestions

### Phase 3: Enterprise Features (Complete)

**Tool Security**
- `ToolSecurityManager` with permission levels: `public`, `restricted`, `dangerous`
- Per-agent allowlist/denylist for tools
- `RateLimiter` with sliding-window algorithm
- Filesystem path checks (allowed/denied paths)
- Network URL checks (allowed/denied URLs)
- `onBeforeToolExecute` callback injection in agent tool loop (keeps `packages/agents` decoupled)
- `SqliteToolAuditStore` logs all tool calls with permit/deny status
- Security events: `security:tool_denied`, `security:rate_limited`, `security:audit_logged`
- REST API: `GET /api/security/audit`, `GET /api/security/audit/:agentId`, `GET /api/security/policy`, `GET /api/security/denied`
- Admin UI: tool audit log with filtering, tool permissions display

**Cost Budgets**
- `BudgetManager` with period-based budgets: `daily`, `monthly`, `total`
- Configurable warning thresholds (e.g., 50%, 80%, 95%)
- Alert logging to `SqliteBudgetStore`
- Period math: daily resets at midnight UTC, monthly resets on 1st
- 429 enforcement on REST routes (agent message endpoint)
- Budget check on WebSocket message processing
- Budget events: `budget:warning`, `budget:exceeded`, `budget:request_blocked`
- Budget events forwarded to WebSocket clients via `WsEventBridge`
- REST API: `GET /api/budgets`, `GET /api/budgets/:id`, `GET /api/budgets/alerts`
- Dashboard UI: budget progress bars (color-coded), budget alerts list

**Workflow Engine**
- `WorkflowDefinition` and `WorkflowStep` types with recursive Zod schemas
- 4 step types: `agent` (send message), `parallel` (concurrent execution), `conditional` (if/else branching), `loop` (iterate over items)
- `WorkflowParser` — YAML to validated `WorkflowDefinition` via Zod + semantic validation (duplicate step IDs)
- `VariableResolver` — resolves `${input}`, `${step.output}`, `${step.error}`, `${step.status}`, and loop variables in message templates
- `WorkflowEngine` — executes steps sequentially, emits lifecycle events, persists to store
- `SqliteWorkflowStore` for workflow definitions and run state
- Workflow events: `workflow:started`, `workflow:step_started`, `workflow:step_completed`, `workflow:step_failed`, `workflow:completed`, `workflow:failed`
- REST API: `POST /api/workflows`, `GET /api/workflows`, `GET /api/workflows/:id`, `DELETE /api/workflows/:id`, `POST /api/workflows/:id/run`, `GET /api/workflows/runs/:runId`, `GET /api/workflows/:id/runs`
- CLI: `fluxmaster workflow validate <file.yaml>` and `fluxmaster workflow run <file.yaml> [--input key=value]`

### CLI (`packages/cli`)
- `fluxmaster init` — generate default config file
- `fluxmaster auth` — check auth status
- `fluxmaster run` — interactive REPL with streaming, agent switching, broadcasting, tool listing, usage tracking
- `fluxmaster workflow validate <file>` — validate YAML workflow definitions
- `fluxmaster workflow run <file>` — execute workflows with input parameters

### Test Coverage
- 771 unit tests across 116 test files
- 45 Playwright E2E tests

---

## Roadmap

### Phase 4: Scale & Teams

**Multi-User & Auth**
- User authentication (OAuth / API key)
- Per-user agent sessions
- Role-based access control (viewer, operator, admin)
- Audit log of all actions

**Observability & Tracing**
- Structured traces with spans (LLM calls, tool calls, MCP calls)
- Waterfall timeline visualization
- P50/P95/P99 latency tracking
- Export to Jaeger/Zipkin/OTLP

**Collaboration Basics**
- Workspaces for team isolation
- Share conversations and workflows
- Comment threads on messages
- Activity feed

### Phase 5: Ecosystem

**Visual Workflow Builder** — Drag-drop canvas for workflow definitions
**Plugin Marketplace** — Registry, discovery, one-click install, publishing
**Advanced Collaboration** — Approval queues, presence indicators, annotations
**Public API & SDK** — REST API docs (OpenAPI), client SDK for integrations

---

## Decisions

| Decision | Rationale |
|----------|-----------|
| **Agent memory via memrl MCP** | memrl provides episodic memory with retrieval, capture, feedback, and utility propagation. Supports cross-project search. Plugs in via existing MCP infrastructure with zero implementation work. Custom memory system deferred indefinitely. |
| **Event bus before features** | Real-time dashboard, webhook integrations, workflow triggers, plugin hooks, and cost tracking all depend on a clean event system. Building features without it means coupling and rework. |
| **SQLite before Postgres** | Single-file database, zero configuration, sufficient for single-user/small-team. Postgres adds operational complexity that's only justified at scale. |
| **Workflow engine before visual builder** | YAML/JSON definitions + list UI delivers 80% of the value at 20% of the cost. Visual canvas is a separate product-level effort. |
| **No custom tool sandbox runtime** | Timeout + process limits on existing tool execution is sufficient. Docker/Firecracker sandboxing is overkill for local tools. Revisit only for untrusted MCP servers. |
| **Plugin marketplace deferred to Phase 5** | Building a registry server, package manager, and verification system is a separate product. Local plugins are sufficient until there's a community. |
| **Lightweight CLI workflow runner** | CLI uses inline `agentManager.routeMessage()` instead of importing `WorkflowEngine` from `@fluxmaster/server`, avoiding heavy server deps (fastify, better-sqlite3) in the CLI package. |
| **Recursive Zod with z.lazy** | WorkflowStep is self-referencing (parallel/conditional/loop contain child steps). Uses `z.ZodType<WorkflowStep, z.ZodTypeDef, unknown>` with `z.lazy()` to avoid circular type inference issues. |

---

## Chat Enhancements (Mid-Term, independent of phases)

These can be implemented incrementally alongside any phase:

- Message search/filter
- Copy message content button
- Regenerate last response button
- Token usage display per message
- File/image upload in chat
- System prompt editor per agent
- Toast notifications for actions (agent spawned, config saved, errors)
- Dark/light theme toggle
- Responsive mobile layout
- Loading skeletons instead of spinners
- MCP server logs viewer in admin
- Tool registry browser with descriptions and schemas
- Config validation with error highlighting
- Agent template presets
